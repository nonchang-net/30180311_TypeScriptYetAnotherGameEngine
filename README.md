# YAGE - Yet Another Game Engine

## 概要

- ゲームのルールエンジン設計プロジェクト。
	- Yet Anotherとあるけど、何かの代替になるようなものを目指しているわけでもない。
	- TypeScriptで簡単なゲームアイデアを実装する際に、ゲームイベントやコンテキスト、メッセージベース処理なんかのテンプレートを作っておきたい……という構想。
	- 「TypeScript+three.jsによる基本プロジェクト」を元に、three.jsを省いて構築。


## ライセンスとか

個人の練習用リポジトリなので転載などはご容赦ください。  
なんか有益なものができたらMIT記載でリポジトリ分けます。


## 実行

npm run dev


## 目標

- メッセージベースのゲームルール評価設計のテンプレート作成

	- まずはProof of Concept。

- ドラクエ風のバトルシステムからモンハンタイプのスキルルールまで、複雑なゲーム設計に耐える、極力汎用化した方法論を検討していく……
	- 理想をぶち上げたけど、とりあえず単純なターンベースバトルゲームをメッセージベースで今風に作ったらどうなるかから見ていく。

## やること

- `実際に自分のゲームで使うときは、git submoduleとして取り込む`形を想定。
	- [Git submodule の基礎](https://qiita.com/sotarok/items/0d525e568a6088f6f6bb)


## 設計メモ

### (Game)Context

- HP、空腹度、所持アイテム、現在のフロア、座標……。
- 何もメソッドを持たなくて良いかも。
- シリアライズできることが要求される。


### ApplicableContext

- xxxContext.Apply()を提供するインターフェース。
- contextAにcontextBをapplyすると、新しい値で上書きして値の変更イベントを飛ばす、という処理を検討。
- XxxxContext自体は「特にインターフェースを持たない自由なクラス」として良さそうなので分ける。


### (不要？) GameEvalutor

- おそらく……なんだけど、GameEvalutor（評価器）は必要ない。これはmain関数に当たるものだ。
- 抽象化が徹底できたときにどうなるかを見てから検討。
	- 評価器は一つのforループで完了するようなものをイメージしている。


### Rule(IRule/IRuleParent)

- Contextと引数を受け取って、ApplicableContextを返す、IRuleまたはIRuleParentインターフェースを実装した多彩なRuleクラスがある。
- modifierである。
	- 変更結果を返すのみで、自分自身は破壊的な変更は行わない。
	- newするコストが多量に発生するが、この問題については一旦考慮から外す。効率に寄せて破壊ForceAppicableContextなどを用意しても良いだろう。
- IRuleインターフェースを実装したRuleクラスが無数にある。
- IRuleParent。これはIRuleを継承し、さらにIRuleのリストを子として持つ。自身の評価の際に、子要素も評価する。


### GameEvent

- あらゆる状況変化はメッセージとして飛び交う。以下はその例。
	- タイトルが表示された。
	- タイトル画面でタップされた。
	- 一歩歩いた。
	- 空腹度が下がった。
	- ダメージを受けた。
	- 歩いて毒のダメージを受けた。
	- 全滅した。
- イベントは、IEventを継承し、コンストラクタに引数があったりなかったりする**だけのもの**だ。
	- 検討: TypeScriptではES Eventを使うべきだろうか？
		- しかしパブリングとかいらんしなぁ。
	- 20180310:
		- とりあえずは、イベント処理モジュールを自作してみた。
		- ボイラープレートコードがあるので理想的ではない感じではあるけど、ゲームイベント定義と実装を切り分けるサンプルにはなったと思う。


### (仮) UIManager

- これの設計は一旦適当でよしとする。上記のイベントモデルの検討とは別。アプリのデモ部分に過ぎないので。
- 以下の仕事をさせることになる。
	- HTMLElementにイベントを登録する。
	- UIと値のバインディングは一旦念頭から除外。
	- イベントを受け取ってHTMLElementなどを更新する。






## 日別ログ

### 20180309金曜日

- 22:11
	- 簡単なゲームを設計するにあたり、自分なりのゲームの設計テンプレートが固まっていないのでTypeScriptでテンプレートを作ろうと考えた。
	- 可能な限り疎結合、プランナーの多彩な要求をまるっと包み込めるような汎用性のある「シンプルな」設計を目指す。
	- とりあえずガワ作成。

### 20180310土曜日

- 14:45
	- 今日は初期コミットまでを目標にしたい。どこを目標にするかな。
		- 仮目標としては「Rule評価までが想定した状態で動くこと」かなぁ。
	- GameEngineとしての部分と、SampleGameとしての実装を分けておこう。
	- DOM Eventに頼らない簡単なイベントを定義しよう。
		- まず参考探す。
			- https://gist.github.com/mindplay-dk/6665405
			- なんか文字列依存……？まあ、シンプルか。
		- できるべきことは、
			- subscribe(this,XxxEvent,(event)=>{xxx})
			- unsubscribeAll(this)
				- thisを渡して、自分が登録した
			- broadcast
				- IEvent実装クラスXxxEventを渡すと、そのXxxEventを購読した全てのlambdaを実行する。

- 18:55
	- 酒飲んでるからでもあるけど、ものすごく時間かかった。

- 00:00
	- 多分**もっとうまくやれる**という不安を抱えながらの作業。
	- ただ、message drivenなコードが書ける基盤にはなったと思う。一旦ここまでをコミットしておこう。first commit。
	- push失敗。
		- git configをsshに合わせる必要がある。
		- git@xxxx:yyyyのxxxxの部分を、github-nonchang-net.comに変更。

	- https://github.com/nonchang-net/30180311_TypeScriptYetAnotherGameEngine
		- うへあ。酔っ払ってるとダメだなぁ。3018？一千年先まではさすがに技術がどんだけ進化しても生きてないと思う……。
		- まあ、いつか直そう。一般化した名前にするかもしれないし。


### 20180311日曜日

- 12:52
	- 設計自体は悪くなかったと思うのだけど、痛恨のミスを感じる。
	- 日記末尾に改善案のメモを分離。
	- 案の定だけど……イベントさばくとStatisDiv/MessageDivクラスそれぞれに購読処理を書く必要が生じて結構うざいなw
		- この辺の購読処理はGameUI.tsにまとめてしまう？ またはGameUIEvents.tsに分けてしまおうか。
		- また、イベントに依存した局所的な引数はやはり必要かもしれない。
			- damagedは「幾つのダメージを受けたのか」という情報が欲しい。
			- 設計メモに。

- 14:05
	- ドラゴンが反撃してくるようにしてみよう。
	- ということで、サブルールの実装。

- 14:26
	- バグがあるなぁ。
	- PlayerDeflatedが表示に反映されない時がある。イベントが飛ばない？
		- ああ、簡単なバグだったw ちょうどhpがゼロになった時にイベント発行してないだけだった。。

- 14:59
	- ドラゴンと殴り合う動きはできた感じがある。
	- 思いつきでいろいろイベントを追加してみよう。まず、攻撃は1/3でミスる。

- 16:01
	- ゲームになってきた感じはある。まだまだイベント遷移がスケールする自信はない。
	- 簡単なGameState管理を実装していこう。

- 16:35
	- 実装できた。コミット。


### 改善案のメモ

- 20180311日曜日

	- `設計上の改善案1`
		- まず、冗長な型情報をどうにかしたい……。
			GameEvent.Manager.subscribe<GameEvent.TestRule.PlayerIntoSleeping>(
				new GameEvent.TestRule.PlayerIntoSleeping((event)=>{
					this.add(`sleepの魔法を受けた。${context.player.name}は眠ってしまった！`)
				})
			)
		- これを、以下のように書きたい。
			GameEvent.Manager.subscribe(EventEnum.PlayerDamaged,(damage)=>{
				this.add(`${context.player.name}は${damage}のダメージを受けた！`)
			})

	- `イベント引数はどう扱うべきか？`
		- スーパーグローバル「GameContext」導入のおかげで、そもそも**イベントは引数を持つ必要がない**状態になっていることに、今更気づいた。
			- それなら、型で頑張らなくてもただのenumでよかったか？
			- いや。damageイベントでは「幾つのダメージを受けたのか」という情報が欲しい。
			- ただのenumではなく、追加のイベント情報を渡せる仕組みはやはり必要かもしれない……。（その意味では、今の設計で各々のイベントがクラスなのは、自由に追加情報を渡せる手軽さと型安全性がある）

	- `thisの撤廃について`
		- 上手くやれてる。
		- モジュール化することで、初期化したら終わり。
		- つまりthis.domなどをプロパティとして保持する必要がなくなってきた。

	- `設計上の懸念点`
		- UIイベントをmain.tsで受け取ってゲームルール評価を再発行しているのはなんか無駄があるように感じる。
		- UIイベント（onclick）で直接rule処理してはいけないだろうか。
			- アリだとは思う。思うけど、責務を分割したい気持ちがある。
			- UIイベントは一旦ロジック側でまとめて受け取って、それに応じた処理を行なった方が良いのか？
			- それとも記述のシンプルさを優先した方がいいのか？
		- これはコメント上の問題だな。現時点での設計は**記述量が少ない方**に寄せて、検討は後日に回そう。

	- `TODO: コマンドバッファを考える`
		- UIは遅滞なく順に「発生したこと」をイベントとして受け取るようになった。
		- ここで、まだ実装するか検討中だけど「タップするまで次のメッセージを表示しない」仕様を考える。
			- キューに追加することになるな。
			- ゲームステートの適切な管理が必要だろう。
			- 行動可能な時とメッセージが残っている時、イベント内容によって画面を揺らしたり効果音を発生したりする必要がある。


`EOF`