# TypeScriptゲーム設計練習リポジトリ

## 概要

- ゲームのルールエンジン設計テスト。

- HTMLのボタンで古典JRPGのバトル部分を最小化したような寸劇が始まります。

- 目的はゲーム設計の基本的な構造のProof of Concept

- メモとか
	- リポジトリ名の名前付けに失敗。別にエンジンでもないし、Yet Anotherと書いてるけど何かの代替でもないです。お気になさらず。
	- TypeScriptで簡単なゲームアイデアを実装する際に、ゲームイベントやコンテキスト、メッセージベース処理なんかの最小構成テンプレートを作っておきたい。


## ライセンスとか

個人の練習用リポジトリなので転載などはご容赦ください。  
なんか有益なものができたらMIT記載でリポジトリ分けます。


## ローカル参照用: リポジトリのURLメモ

https://github.com/nonchang-net/30180311_TypeScriptYetAnotherGameEngine

- リポジトリ名2018にするつもりが3018にしちゃった。後で直します。


## 実行

npm run dev




## 設計メモ

現状の、主な指針は以下。

- メッセージドリブン、Pub/Sub、イベント駆動
- Data Oriented Programming
- コンポーネント指向……というか、「継承よりコンポジション」

サンプルコードではDI（コンストラクタインジェクション）も徹底しているけど、特に言及は避けます。

ベーシックなオブジェクト指向を否定するものではないけど、カプセル化を壊すようなことに言及しているのでご注意。



### MasterData

- 何よりも先に初期化される、ゲーム内で固定のデータを配信するシステム。本サンプルではモックアップデータを用意。

- マスターデータの例としては、アイテム情報、モンスター情報、経験値テーブルなど。

- このサンプルではただのJSONである。

- 実務では、データソースとしてGoogle Spread Sheetを用意して、プランナーがゴリゴリ書いて、デプロイスクリプトを用意してGAS経由でJSONに変換し、AWS S3に配置することになる。

- ゲーム開発のイテレーションを高めるためには必須の仕組みの一つ。



### Context

- ゲームの状態を示すデータクラスの集合体。
	- この設計で採用した造語。
	- ただのデータクラス。
	- 強いてMVCで言えば、Modelからデータ構造だけ抜き出したもの。
	- Contextは、例えばPlayer、Enemy、Mapといったデータ構造定義をサブコンテキストとして持っている。

- 具体的な実装は持たない。
	- getter/setter程度はあっても良い。

- 後述のRuleが、Contextに副作用を与えてゲームを処理し、イベントを飛ばして演出を進行させる。

- Contextをシリアライズすればゲームのセーブになり、デシリアライズして初期化ルーチンを通ればゲームのロードになる。

- そのまま持ち回すとスーパーグローバルなので注意。
	- 影響範囲を最小化するように、Rule関数に渡していく。
	- 攻撃RuleであればPlayerとEnemyを渡せば良い、というように。イベントを飛ばせば処理可能な要素は持たない。



### Rules

- RuleはMVCで比喩するほどのものでもなく、強いて言えばMVCのModelのロジックだけを抽出したもの。データ定義も持たない。

- Ruleはただの関数。ただのメソッド。

- Contextを与えるとContextを加工するもの。副作用を与えるだけ。結果を返したりはしない。

- 基本的にはシンプルなメソッドか、内部で複数のRuleを呼ぶ。
	- 「Buttle.Attack」ルールは、Actorを二つ引数に与えられると、前者のActorが所持している武器で後者のActorを攻撃するルールを適用する。

- 状況に応じて、イベントを飛ばす。UI更新要求、敵を倒したなどのシーン遷移イベントなど。

- Ruleが実行されるタイミングは以下。

	- （雑に）UI操作時に直接呼び出される。
		- 本格的な開発時は、直接呼び出すのは避けた方が良さそう。UI操作時はイベント飛ばすだけにして、後述のSubscriberに任せるべきだろう。

	- イベント発生時に、Subscriberが呼び出す。

	- 他のRuleから呼び出されることもある。



### Subscriber

- イベントを購読し、Ruleを実行する補助クラス。
	- サンプルゲームでは使ってない。

- 典型的にはUI処理の抽象化。
	- マウスの右クリックとキーボードのescキーに同じ「メニューを開く」という処理を実装したい場合は、このListenersが「OpenMenu」イベントを購読する。

- Subscriberはイベントを購読するだけの存在であり、コンストラクタしか持たない。
	- contextを引数にとってnewされて、main.tsに保持されるだけの存在。



### Events

- ゲーム中の操作、表示更新要求
- TSでsubscribe/unsubscribe/broadcastできるだけのシンプルかつ型安全なイベントの仕組みを実装したのでこれを使います。



### UI

このサンプルゲームでは実に適当な実装です。

- オールドスタイルなDOM操作。

- HTMLElementにonclickでDOMイベントを登録。

- 前述のイベントを購読して受け取ってHTMLElementなどを更新する。



## この設計による恩恵は何か

- 仕様変更への強さ、開発実装中に考えることを減らせること

	- これらは実は同等で、ルールが決まっていることと、ワークフローが決まっていることに相当します。
	- 我々はMasterDataに必要な情報を追加して、Contextに必要な情報を追加して、Ruleを追加して、Eventを追加して、UIを追加すれば良いのです。
	- コード上は既存のContext|Rule|Event|UIをコピペして、名前を変えるところから始めれば良い。





```
  ****    **        ******  
**    **  **          **    
********  **          **    
**    **  **          **    
**    **  ********    **    
```

### 自己批判、対案のメモなど


#### なんでTypeScriptやねん

TypeScriptでWebGL遊び始めてるからです。  
型安全でシンプルなイベントを試したかったというのもありますが、そのうちvanillaなjavascriptで書き直してみたい。

TypeScriptいいですよ。


#### Ruleに疑問

Ruleの設計は少し懐疑的。  

- 引数が増える。
	- 処理に必要な要素を「全て引数で渡す」ことになる。
	- 結合度の面では理想的なのだけど、決してOOP的ではない。

- Contextから生やせばメソッドチェーンができたように思う。
	- this参照できて記述量を減らせた可能性もあるのだけど、問題はサブコンテキストを渡すルールを徹底しにくくなる点。
	- Attackルールが「どこから生えてるか」を探すことにもなるだろう。今回のサンプルでは、ルールがPlayerクラスから生えている、という状況は理想的ではなかった。

これらの難点は、DIの自動化ライブラリや、TypeScriptでコンポーネント指向を補助するライブラリでいいものが見つかれば解決できそうに感じています。  
個人的にはUnityのZenjectが理想的かも。（新規入場者がキャッチアップに戸惑ってるけど、理解できない人はいないので、単に現場のドキュメンテーション不足だと思う）  

TypeScriptもデコレータで同様のことが実現できないのかなぁ、とか想像していますがまだ深追いしていない状況。


#### Contextに疑問

- 

- UserDataじゃだめだったのか。
	- シーンのステートとか入れたくない気がしたんですよね。UserData。
	- GameDataってちょっと言葉が広すぎる。
	- うーん。
	- 今回は、Android開発時に見た用語を適当に当ててみた感じ。


```
******    ****    ******      ****    
  **    **    **  **    **  **    **  
  **    **    **  **    **  **    **  
  **    **    **  **    **  **    **  
  **      ****    ******      ****    
```

### TODO: 改善案のメモ


#### 20180312月曜日

- イベントの整理に伴い、「GameRules.ts」の冗長さが気になった。ルール評価の結果、直接Context書き換えでいいような気がするな。今isSleepフラグだけマージしてるけど意味ない。

- コンストラクタDI前提な書き方でいいのかなぁ。
	- 規模が大きくならなければ、重厚なDIは不要だと思うのだけども。
		- main.tsの最初の初期化で順序依存が発生しているように見えてしまうのがなんとなく嫌ではある。

- `TODO` GameRule周りの再検討
	- 汎用性の目安として、「ルール適用の履歴保存」が可能な設計を目標としたい。（リプレイ保存・再生など）
	- ApplicableContextは排除したい。即時適用で良い。
		- リプレイに関すると、ランダム性のある「動的ルール」とそうでない「静的ルール」を厳密に分類していった方がいいのかなぁ。
		- この辺を考えて詰めていく。

- `要検討`
	- ワークフローを詰めると、手順としては「Rules/Item.ts」を編集するときは、同時に「Contexts/Item.ts」「Events/Item.ts」を編集する必要が生じるのではないだろうか。
	- 「スケールする構成」について考えたいところだ。
		- これらを同じフォルダに入れる方がいいのか？
		- もっと言えば、小さい単位ならこれらを同じファイルに入れてしまってコンポーネントとしてしまった方が良かったりして……？
		- 要検討。


#### 20180311日曜日

- `TypeScriptのthisの撤廃について`
	- 上手くやれてるところもある
	- モジュール化することで、初期化したら終わり。
	- つまりthis.domなどをプロパティとして保持する必要がなくなってきた。
	- 必要なところも多いので、`いかに減らすか`は検討したい。極力宣言的に書いていくことが要求されそうだ。


- `設計上の懸念点`
	- UIイベントをmain.tsで受け取ってゲームルール評価を再発行しているのはなんか無駄があるように感じる。
	- UIイベント（onclick）で直接rule処理してはいけないだろうか。
		- アリだとは思う。思うけど、責務を分割したい気持ちがある。
		- UIイベントは一旦ロジック側でまとめて受け取って、それに応じた処理を行なった方が良いのか？
		- それとも記述のシンプルさを優先した方がいいのか？
	- これはコメント上の問題だな。現時点での設計は**記述量が少ない方**に寄せて、検討は後日に回そう。


- `TODO: コマンドバッファを考える`
	- UIは遅滞なく順に「発生したこと」をイベントとして受け取るようになった。
	- ここで、まだ実装するか検討中だけど「タップするまで次のメッセージを表示しない」仕様を考える。
		- キューに追加することになるな。
		- ゲームステートの適切な管理が必要だろう。
		- 行動可能な時とメッセージが残っている時、イベント内容によって画面を揺らしたり効果音を発生したりする必要がある。



- `TODO` 次は経験値を稼いでレベルアップできるようにしたいなぁ。
	- レベルアップマスターが必要だな……。
	- 先にセーブ・ロードか？

- `TODO` セーブ・ロード。
	- speck暗号を適用したい。


`EOF`